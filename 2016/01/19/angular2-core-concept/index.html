<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Angular2核心概念 | MigicQ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="description" content="Angular2核心概念，关注angular2、ReactiveExtension等最新内容。Angular2,angular,Angular">
    
    
    
      <meta name="keywords" content="Angular2,Angularjs2,javascript,慕慕珍珍,曹莅祥,caolixiang,caolixiang33,rxjs教程,rxjs入门教程,rxjs入门,angular2教程,angular2入门教程,angular2入门">
    
  
    <link rel="alternative" href="/atom.xml" title="MigicQ" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xq0ve.com1.z0.glb.clouddn.com/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xq0ve.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-14%20%E4%B8%8B%E5%8D%8811.46.55.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">慕慕珍珍</a></h1>
		</hgroup>

		
		<p class="header-subtitle">The winter is coming.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="weibo" target="_blank" href="http://weibo.com/caolixiang" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailTo:caolixiang@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Angular2/" style="font-size: 10px;">Angular2</a> <a href="/tags/Angularjs2/" style="font-size: 10px;">Angularjs2</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/RxJS/" style="font-size: 15px;">RxJS</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">慕慕珍珍</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xq0ve.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-14%20%E4%B8%8B%E5%8D%8811.46.55.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">慕慕珍珍</h1>
			</hgroup>
			
			<p class="header-subtitle">The winter is coming.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="weibo" target="_blank" href="http://weibo.com/caolixiang" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailTo:caolixiang@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-angular2-core-concept" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/19/angular2-core-concept/" class="article-date">
  	<time datetime="2016-01-19T01:22:30.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Angular2核心概念
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular2/">Angular2</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angularjs2/">Angularjs2</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文地址： <a href="http://victorsavkin.com/post/118372404541/the-core-concepts-of-angular-2" target="_blank" rel="external"><em>THE CORE CONCEPTS OF ANGULAR 2</em></a></p>
</blockquote>
<p>这篇博客中，我们将介绍Angular 2的三个核心概念：<strong>组件化</strong>，<strong>依赖注入</strong>，<strong>绑定</strong>。</p>
<blockquote>
<p><em>最后更新：2016-01-04</em></p>
</blockquote>
<h3 id="u514D_u8D23_u58F0_u660E"><a href="#u514D_u8D23_u58F0_u660E" class="headerlink" title="免责声明"></a>免责声明</h3><blockquote>
<p>Angular 2仍然在开发之中，核心概念不会随之变化，但是相关API可能会随着项目的开发进程发生改变：如果发现博文中某些代码片段无法运行了，请告知我，我会进行更新。</p>
</blockquote>
<hr>
<h3 id="u5F00_u59CB_u6784_u5EFAAPP_u5427"><a href="#u5F00_u59CB_u6784_u5EFAAPP_u5427" class="headerlink" title="开始构建APP吧"></a>开始构建APP吧</h3><p>现在我们描述一下将要构建的应用：它包含了一个科技讲座的列表，你可以通过讲师<code>speaker</code>进行筛选，观看讲座或对讲座进行评分，应用Demo如下：</p>
<p><img src="http://40.media.tumblr.com/fd37a5ff9a41cf25ed57236092b708c6/tumblr_nnzn556v7F1qc0howo1_500.png" alt="appWeWillBuild"></p>
<hr>
<h3 id="u7EC4_u4EF6"><a href="#u7EC4_u4EF6" class="headerlink" title="组件"></a>组件</h3><p>你需要定义UI、路由等一系列组件去构建一个Augular 2应用。一个应用中总是存在一个根(主)组件，根组件中包含了其他组件。简而言之，每一个Angular 2应用都有一棵对应的<strong>组件树</strong>。我们应用的组件树看起来是这样的：</p>
<p><img src="http://40.media.tumblr.com/4f7c8180305cd3641ebc52eb1a628ed0/tumblr_nnzn556v7F1qc0howo2_1280.png" alt="ourApp&#39;sComponentsTree"></p>
<p><code>Application</code>是<strong>根组件</strong>；<code>Filters组件</code>包含一个演讲者<code>speaker</code>姓名输入框和筛选按钮；<code>TalkList</code>是你在Demo中看到的讲座列表；<code>TalkCmp</code>是讲座列表中的一个元素(一个讲座)。</p>
<p>为了理解Angular 2中组件的构成，我们先研究一下<code>TalkCmp</code>：</p>
<blockquote>
<p>TalkCmp.ts:</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'talk-cmp'</span>,</span><br><span class="line">  directives: [FormattedRating, WatchButton, RateButton],</span><br><span class="line">  templateUrl: <span class="string">'talk_cmp.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> TalkCmp &#123;</span><br><span class="line">  @Input() talk: Talk;</span><br><span class="line">  @Output() rate: EventEmitter;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>talk_cmp.html</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;talk.title&#125;&#125;</span><br><span class="line">&#123;&#123;talk.speaker&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="title">formatted-rating</span> [<span class="attribute">rating</span>]=<span class="value">"talk.rating"</span>&gt;</span><span class="tag">&lt;/<span class="title">formatted-rating</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">watch-button</span> [<span class="attribute">talk</span>]=<span class="value">"talk"</span>&gt;</span><span class="tag">&lt;/<span class="title">watch-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">rate-button</span> [<span class="attribute">talk</span>]=<span class="value">"talk"</span>&gt;</span><span class="tag">&lt;/<span class="title">rate-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="INPUT__26amp_3B_OUTPUT__u5C5E_u6027"><a href="#INPUT__26amp_3B_OUTPUT__u5C5E_u6027" class="headerlink" title="INPUT &amp; OUTPUT 属性"></a>INPUT &amp; OUTPUT 属性</h4><p>每一个组件都拥有<code>input</code>、<code>output</code> 属性，我们可以在组件中通过属性装饰符语法定义这些属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> TalkCmp &#123;</span><br><span class="line">  @Input() talk: Talk;</span><br><span class="line">  @Output() rate: EventEmitter;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过<code>input</code>属性，数据可以流入到组件中；通过<code>output</code>属性，数据可以从组件中流出。</p>
<p><img src="http://40.media.tumblr.com/8d2360fe8f3f0c66b20cb5dcc45856ce/tumblr_nnzn556v7F1qc0howo3_1280.png" alt="flows in and out"></p>
<p><code>Input</code> 和 <code>output</code> 是组件提供的公共API，在应用中初始化组件时你可以使用它们。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">talk-cmp</span> [<span class="attribute">talk</span>]=<span class="value">"someExp"</span> (<span class="attribute">rate</span>)=<span class="value">"eventHandler($event.rating)"</span>&gt;</span><span class="tag">&lt;/<span class="title">talk-cmp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过属性绑定(使用方括号语法)，你可以设置<code>input</code>属性的值；通过事件绑定，(使用圆括号语法)，你可以绑定<code>output</code>属性。</p>
<p>每一个组件总是有一个模板与之对应，模板定义了一个组件在页面中的渲染方式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'talk-cmp'</span>,</span><br><span class="line">  directives: [FormattedRating, WatchButton, RateButton],</span><br><span class="line">  templateUrl: <span class="string">'talk_cmp.html'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>talk_cmp.html</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;talk.title&#125;&#125;</span><br><span class="line">&#123;&#123;talk.speaker&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="title">formatted-rating</span> [<span class="attribute">rating</span>]=<span class="value">"talk.rating"</span>&gt;</span><span class="tag">&lt;/<span class="title">formatted-rating</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">watch-button</span> [<span class="attribute">talk</span>]=<span class="value">"talk"</span>&gt;</span><span class="tag">&lt;/<span class="title">watch-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">rate-button</span> [<span class="attribute">talk</span>]=<span class="value">"talk"</span>&gt;</span><span class="tag">&lt;/<span class="title">rate-button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为进行渲染，Angular需要事先知道：渲染中可以使用哪些<code>directives</code>？使用什么样的模板？你可以用<code>templateUrl</code>把模板文件定义在外部文件中，或者使用内联的方式像下面这样进行定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: 'talk-cmp',</span><br><span class="line">  directives: [FormattedRating, WatchButton, RateButton],</span><br><span class="line">  template: `</span><br><span class="line">    &#123;&#123;talk.title&#125;&#125;</span><br><span class="line">    &#123;&#123;talk.speaker&#125;&#125;</span><br><span class="line">    &lt;formatted-rating [rating]="talk.rating"&gt;&lt;/formatted-rating&gt;</span><br><span class="line">    &lt;watch-button [talk]="talk"&gt;&lt;/watch-button&gt;</span><br><span class="line">    &lt;rate-button [talk]="talk"&gt;&lt;/rate-button&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h4><p>Angular 2为组件定义了完整的生命周期，你可以在组件各个生命周期中进行介入。在<code>TalkCmp</code>组件中，我们没有订阅其生命周期中的事件，这并不代表其他组件不能。下面例子中的组件会在<code>input</code>属性变化时收到通知。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;selector: <span class="string">'cares-about-changes'</span>&#125;)</span><br><span class="line"><span class="keyword">class</span> CareAboutChanges &#123;</span><br><span class="line">  @Input() field1;</span><br><span class="line">  @Input() field2;</span><br><span class="line">  onChange(changes) &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u670D_u52A1_u63D0_u4F9B_u8005"><a href="#u670D_u52A1_u63D0_u4F9B_u8005" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>一个组件可以包含一系列服务提供者，其子组件也可以使用这些服务。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'conf-app'</span>,</span><br><span class="line">  providers: [ConfAppBackend, Logger]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> TalksApp &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TalksCmp &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(backend:ConfAppBackend) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们在<strong>根组件</strong>中声明了后端服务(即服务器通信)和日志服务，这样在应用中我们都可以使用这些服务。接下来<code>talksCmp</code>组件注入后端服务(因为<code>ConfAppBackend</code>在<strong>根组件</strong>中做过声明)。<br>我们会在本文的第二部分详细地介绍<strong>依赖注入</strong>，这里我们只用了解：通过组件进行<strong>依赖注入</strong>的设置。</p>
<h4 id="u5BBF_u4E3B_u5143_u7D20"><a href="#u5BBF_u4E3B_u5143_u7D20" class="headerlink" title="宿主元素"></a>宿主元素</h4><p>为了将Angular组件渲染成DOM树，需要将Angular组件与一个DOM元素相关联，我们把这样的DOM元素称为：<strong>宿主元素</strong>。</p>
<p>组件可以与宿主元素进行如下方式的交互：</p>
<ul>
<li>监听宿主元素事件</li>
<li>更改宿主元素属性</li>
<li>调用宿主元素方法</li>
</ul>
<p>下面这个组件中，通过<code>HostListener</code>监听宿主元素的输入事件，然后去除输入值两端的空格，并将其存储。Angular 会时时保持DOM元素与存储值的一致性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;selector: <span class="string">'trimmed-input'</span>&#125;)</span><br><span class="line"><span class="keyword">class</span> TrimmedInput &#123;</span><br><span class="line">  @HostBinding() value: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  @HostListener(<span class="string">"input"</span>, <span class="string">"$event.target.value"</span>)</span><br><span class="line">  onChange(updatedValue: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = updatedValue.trim();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请注意</strong>，上面的例子中我对DOM元素进行操作。Angular 2致力于提供更高层面的抽象接口：我们可以将Angular 2应用<strong>映射</strong>到<strong>原生平台</strong>(比如iOS、Android)或者<strong>浏览器中</strong>。</p>
<p>这个理念极为重要，因为：</p>
<ul>
<li>我们可以更为方便地重构应用<code>(与DOM解耦)</code></li>
<li>可以脱离DOM进行大多数单元测试。测试脚本会变得更加利于理解和编写，测试效率也会显著提升</li>
<li>可以在<strong>web worker</strong>中运行Angular 2应用</li>
<li>可以脱离浏览器环境，例如使用<code>NativeScript</code>可以在<code>iOS</code>、<code>Android</code>平台运行Angular 2应用</li>
</ul>
<p>但是有些时候，我们还是需要和DOM直接打交道。Angular 2 提供了这类接口，不过我们希望你能尽可能少地使用它们。 </p>
<h4 id="u7EC4_u4EF6_u662F_u5B9A_u4E49_u5B8C_u5907_u7684"><a href="#u7EC4_u4EF6_u662F_u5B9A_u4E49_u5B8C_u5907_u7684" class="headerlink" title="组件是定义完备的"></a>组件是定义完备的</h4><p>组件由下面这些部分构成：</p>
<ul>
<li>组件知道如何与宿主元素进行交互</li>
<li>组件知道如何对自身进行渲染</li>
<li>组件可以进行<strong>依赖注入</strong>的设置</li>
<li>组件有定义<code>inputs</code>和<code>outputs</code>属性的接口</li>
</ul>
<p>这些部分让Angular 2元素具备了自我完备定义的能力，我们可以独立地初始化一个组件，因为<strong>组件是定义完备的</strong>。</p>
<p>任意组件都可以<code>bootstrap</code>一个应用；任意组件都可以绑定在特定路由之上并渲染。任意组件可以被其他组件直接使用。虽然我们定义的接口更少了，的但是带来了高可复用性。</p>
<h4 id="u90A3_u4E48DIRECTIVES_u5462_3F"><a href="#u90A3_u4E48DIRECTIVES_u5462_3F" class="headerlink" title="那么DIRECTIVES呢?"></a>那么<code>DIRECTIVES</code>呢?</h4><p>如果你熟悉Angular 1，你一定会问：“<code>directives</code>去哪里了？”</p>
<p>其实，<code>directives</code>一直都在。组件是最为重要的<code>directives</code>，但并不是唯一的<code>directives</code>。组件是具有模板的<code>directive</code>，你可以使用装饰器语法来定义没有模板的<code>directive</code>。</p>
<p><img src="http://40.media.tumblr.com/a35e02840c12d0945d16ed0087e23974/tumblr_nnzn556v7F1qc0howo4_400.png" alt="componentsAndDirectives"></p>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>组件是构建 Angular 2应用的基础：</p>
<ul>
<li>它们有定义<code>inputs</code>和<code>outputs</code>属性的接口</li>
<li>有完整的生命周期</li>
<li>是定义完备的</li>
</ul>
<hr>
<h3 id="u4F9D_u8D56_u6CE8_u5165"><a href="#u4F9D_u8D56_u6CE8_u5165" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>现在讨论 Angular 的另一个重要基石——依赖注入。</p>
<p>依赖注入背后的思想很简单：如果一个组件依赖一项服务，那么组件不应该去直接生成这个服务实例。通过在构造方法<code>constructor</code>中注入，框架(指 Angular 2的 <code>DI</code> 框架)会把服务提供给你。<strong>面向接口编程而非实现进行编程</strong>，可以<strong>降低代码的耦合度</strong>，提高<strong>可测试性</strong>(比如<code>mocking</code>数据)，带来诸多其他好处。</p>
<p><img src="http://41.media.tumblr.com/c5b2e9096e2b877c856ef549ad211ac0/tumblr_nnzn556v7F1qc0howo5_1280.png" alt="DI"></p>
<p>Angular 2与生俱来拥有一个依赖注入模块(当然该模块可以脱离Angular 2与其他库结合使用)。我们试着从下面的组件了解如何进行依赖注入。这个组件会渲染讲座列表。 </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'talk-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'talks.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> TalkList &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">    <span class="comment">//..获取数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>talks.html</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>Talks:<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> *<span class="attribute">ngFor</span>=<span class="value">"#t of talks"</span>&gt;</span></span><br><span class="line">  &#123;&#123;t.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们构造一个服务来提供模拟数据：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TalksAppBackend &#123;</span><br><span class="line">  fetchTalks() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &#123; name: <span class="string">'Are we there yet?'</span> &#125;,</span><br><span class="line">      &#123; name: <span class="string">'The value of values'</span> &#125;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们如何调用这个服务？一种实现是：在我们的组件中创建一个服务对象的实例，并调用实例方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TalkList &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> backend = <span class="keyword">new</span> TalksAppBackend();</span><br><span class="line">    <span class="keyword">this</span>.talks = backend.fetchTalks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为应用Demo来说，这么做没有问题。但是真实应用中这的确不是一个很好的解决方案。<code>TalksAppBackend</code>的作用不单单是返回一个讲座对象的数组，它同样需要通过<code>http</code>请求获得数据：在单元测试中，我们理应需要发起<code>http</code>请求。<br>问题在于：我们在<code>TalkList</code>中创建<code>TalksAppBackend</code>的实例造成了代码的耦合(从面向对象<strong>单一职责</strong>的原则看，<code>TalkList</code>不应该关心<code>TalksAppBackend</code>的具体实现)。</p>
<p>通过在构造方法中注入<code>TalksAppBackend</code>可以解决这个问题，注入的服务可以在测试中简单地替换，比如下面这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TalkList &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(backend:TalksAppBackend) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.talks = backend.fetchTalks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码告知 Angular<code>TalksList</code> 依赖于 <code>TalksAppBackend</code>。我们同样需要告知Angular 如何创建 <code>TalksAppBackend</code>服务。通过在组件中加入<code>providers</code>属性可以完成这个工作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'talk-list'</span>,</span><br><span class="line">  templateUrl: <span class="string">'talks.html'</span>,</span><br><span class="line">  providers: [TalksAppBackend]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> TalkList &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(backend:TalksAppBackend) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.talks = backend.fetchTalks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TalksAppBackend</code>服务需要在<code>TalkList</code>或者它的祖先组件中进行声明。如果你习惯于 Angular 1 的编程风格，你可以在<strong>根组件</strong>中设置所有的<code>providers</code>。这样，所有的组件都可以直接使用这些服务了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'talk-app'</span>,</span><br><span class="line">  providers: [TalksAppBackend] <span class="comment">// 在根组件中注册，之后所有应组件都可以直接注入这些服务。</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> Application &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'talk-list'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> TalkList &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(backend:TalksAppBackend) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.talks = backend.fetchTalks();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7EDF_u4E00_u7684_u4F9D_u8D56_u6CE8_u5165_u63A5_u53E3"><a href="#u7EDF_u4E00_u7684_u4F9D_u8D56_u6CE8_u5165_u63A5_u53E3" class="headerlink" title="统一的依赖注入接口"></a>统一的依赖注入接口</h4><p> <code>Angular 1</code> 和 <code>Angular 2</code>都有各自的依赖注入模块。在<code>Angular 1</code>中，框架提供了好几种依赖注入接口，有按照位置注入的(如 <code>element</code>)，有按照名称注入的，有一点让人困惑。<code>Angular 2</code>提供了单一的依赖注入接口。所有依赖注入都在组件的构造方法中完成。</p>
<p> 比如，下面的组件注入了<code>TalksAppBackend</code>(一般都是单例的)，<code>ElementRef</code>(对于每一个组件都不同)。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TalksList &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(elRef:ElementRef, backend:TalksAppBackend) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对于全局或者本地的依赖注入都使用同样的接口，即便是在一个组件中注入其他的组件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Component &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(ancestor:AncestorCmp) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5C0F_u7ED3-1"><a href="#u5C0F_u7ED3-1" class="headerlink" title="小结"></a>小结</h4><p>我们并不会在使用依赖注入后马上受益。但然后随着应用复杂度的增加，使用依赖注入会越来越重要。</p>
<p>依赖注入使得我们面向接口而不是实现进行编程，大大降低了代码的耦合性，提高了可测试性。同时Angular 2提供了统一的依赖注入接口。</p>
<h3 id="u5C5E_u6027_u7ED1_u5B9A"><a href="#u5C5E_u6027_u7ED1_u5B9A" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>Angular通过属性绑定自动同步组件树、模型和组件树对应的DOM结构，为了理解其重要性，我们再回顾一下第一节中的应用。</p>
<p><img src="http://40.media.tumblr.com/fd37a5ff9a41cf25ed57236092b708c6/tumblr_nnzn556v7F1qc0howo1_500.png" alt="application"></p>
<p>我们知道，用户在输入演讲者<code>speaker</code>后，会产生一颗组件树，以及对应的模型。假设模型是简单的<code>Javascript</code>对象，并且看起来是这个样子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  filters: &#123;</span><br><span class="line">    speaker: <span class="string">"Rich Hickey"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  talks: [</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">"Are we there yet?"</span>,</span><br><span class="line">      speaker: <span class="string">"Rich Hickey"</span>,</span><br><span class="line">      yourRating: <span class="literal">null</span>,</span><br><span class="line">      avgRating: <span class="number">9.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们试着来改变模型。假设我看了这个演讲<code>Are we there yet?</code>并且觉得很赞，给了9.9的评分，模型会变为下面的结构。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  filters: &#123;</span><br><span class="line">    speaker: <span class="string">"Rich Hickey"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  talks: [</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">"Are we there yet?"</span>,</span><br><span class="line">      speaker: <span class="string">"Rich Hickey"</span>,</span><br><span class="line">      yourRating: <span class="number">9.9</span>,</span><br><span class="line">      avgRating: <span class="number">9.0</span>?</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我需要找到依赖于这个值(我的评分)的所有部分并且更新它们，过程繁琐且易出错。我们希望应用能够自动地映射值的改变，而属性绑定正好能够赋予我们。</p>
<p>在<code>虚拟机</code>每一循环周期的末尾，Angular会检查组件树中的每一个组件，更确切地说，它将会检查每一个绑定的属性(所有<code>[]</code>和<code>{}</code>)，并且更新这些组件，在更新组件的同时，Angular也会依照组件树更新对应的DOM结构。</p>
<p><em>仅仅使用了属性绑定的<code>input</code>属性可以被更新。</em></p>
<h4 id="ZONES"><a href="#ZONES" class="headerlink" title="ZONES"></a>ZONES</h4><p>Angular 1中我们需要通过<code>scope.$apply</code>告知框架进行脏值检查。Angular 2 通过使用 Zone.js 进行脏值检查，这意味着在使用第三方库时，你再也不需要使用<code>scope.$apply</code>进行脏值检查了，全部交给框架就好了。</p>
<h4 id="u5C0F_u7ED3-2"><a href="#u5C0F_u7ED3-2" class="headerlink" title="小结"></a>小结</h4><p>Angular 2 通过属性绑定，同步组件树、模型和组件树对应的DOM结构。<br>Angular 2 使用 Zone.js 来获知进行同步的时间点。</p>
<h3 id="u56DE_u987E"><a href="#u56DE_u987E" class="headerlink" title="回顾"></a>回顾</h3><p><code>Directives</code>特别是组件，是 Angular 2 中最重要的部分：它们是构建 Angular 2 应用的基础。组件时定义完备的，可以通过接口定义组件的<code>inputs</code>、<code>outputs</code>属性。组件通过私有API，来在组件各个生命周期产生<strong>钩子</strong>。组件可以与宿主元素进行交互。当组件需要依赖其他服务或组件时，Angular 提供了依赖注入。组件树，是 Angular 2的核心，使用属性绑定和<code>Zone.js</code>使得Angular 2的开发更加便捷。</p>
<p>在开始 Angular 2 之前请先充分地理解上面这些概念。当然实际工程中需要的知识远不止这些，这也是为什么我们在 Angular 2 核心的基础上又构建了一系列模块的原因，它们使得开发体验更加愉悦，这些模块包括：</p>
<ul>
<li>处理表单和输入的模块</li>
<li><code>http</code>模块</li>
<li>强大的路由模块</li>
<li>对动画的支持的模块</li>
<li>基于<code>material</code>设计风格的UI组件</li>
<li>用以进行单元测试、端对端和性能测试的工具集</li>
</ul>
<p>还有许多特性尚在开发之中，目前为止进展顺利。</p>
<h3 id="u62D3_u5C55_u8D44_u6599"><a href="#u62D3_u5C55_u8D44_u6599" class="headerlink" title="拓展资料"></a>拓展资料</h3><p><a href="https://angular.io/" target="_blank" rel="external">angular.io</a> 中有快速教程，手把手指南和API文档。<br><a href="https://www.youtube.com/watch?v=3IqtmUscE_U" target="_blank" rel="external">Brian Ford对Zone的介绍</a>： 如果你想深入了解<code>Zone.js</code>可以去看这个视频(需要翻墙%&gt;_&lt;%)。<br><a href="http://victorsavkin.com/post/110170125256/change-detection-in-angular-2" target="_blank" rel="external">Angular 2中的脏值检查</a>：深度解析了神奇的属性绑定背后的脏值检查。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/01/17/rx-api-catch/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">RxJS API解析（三）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 慕慕珍珍
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>